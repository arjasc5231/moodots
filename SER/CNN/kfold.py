# -*- coding: utf-8 -*-
"""kfold.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gJtZSdZ3x6J1J3JpMgl261JzDgKuuOt0
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.utils import to_categorical
import numpy as np
from sklearn.model_selection import StratifiedKFold

def kfold(k, create_model, X, Y, lr, batchs, epochs, print_cycle):
  """
  statified kfold
  argument:
    k : number of folds
    create_model : function for creating model object (keras)
    X : 3D input (numpy)
      (np.concatenate((X_train, X_test), axis=0) if need)
      (np.expand_dims(X, axis=-1) if need)
    Y : 1D expected output (numpy). number of label=7 (not one-hot)
    lr : learning rate
    batchs : batch size
    epochs : number of epochs
    print_cycle : in train step, cycle of epochs that print accuracy
  
  using adam opt
  
  how to use:
    import sys
    sys.path.append("/content/drive/MyDrive/team_runner/colab/emoDB/CNN")
    from kfold import kfold
  """
  Y_origin = Y[:]
  Y= to_categorical(Y, 7)


  def loss_fn(model, images, labels):
    logits = model(images, training=True)
    loss = tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_pred=logits, y_true=labels, from_logits=True))    
    return loss
    
  def grad(model, images, labels):
    with tf.GradientTape() as tape: loss = loss_fn(model, images, labels)
    return tape.gradient(loss, model.variables)
    
  def evaluate(model, images, labels):
    logits = model(images, training=False)
    correct_prediction = tf.equal(tf.argmax(logits, 1), tf.argmax(labels, 1))
    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
    return accuracy

  
  print(f'Learning started. k={k}')
  fold = 1
  fold_train_acc = []
  fold_test_acc = []
  conf_mat = [[0]*7 for i in range(7)]
  for train_idx, test_idx in StratifiedKFold(n_splits=k, shuffle=True).split(X,Y_origin):
    model = create_model()
    optimizer = tf.optimizers.Adam(learning_rate=lr)
    X_train, Y_train = X[train_idx], Y[train_idx]
    X_test, Y_test = X[test_idx], Y[test_idx]
    train_dataset = tf.data.Dataset.from_tensor_slices((X_train, Y_train)).batch(batchs)
    test_dataset = tf.data.Dataset.from_tensor_slices((X_test, Y_test)).batch(batchs)

    print(f'<<fold {fold}>>')
    print('Epoch\tloss\t\ttrain acc\ttest acc')

    for epoch in range(1,epochs+1):
      loss = 0.
      train_acc = 0.
      test_acc = 0.
      max_train_acc = 0.
      max_test_acc = 0.
      
      for images, labels in train_dataset:
          grads = grad(model, images, labels)                
          optimizer.apply_gradients(zip(grads, model.variables)) 
          loss += loss_fn(model, images, labels)
          train_acc += evaluate(model, images, labels)
      loss /= len(train_dataset)
      train_acc /= len(train_dataset)
      max_train_acc = max(max_train_acc, train_acc)
      
      for images, labels in test_dataset:
          test_acc += evaluate(model, images, labels)
      test_acc /= len(test_dataset)  
      max_test_acc = max(max_test_acc, test_acc)

      if epoch%print_cycle==0: print(f'{epoch}  \t{loss:.4f}  \t{train_acc:.4f}  \t{test_acc:.4f}')
    
    print(f'max train accuracy: {max_train_acc:.4f}')
    print(f'max test accuracy: {max_test_acc:.4f}')
    fold_train_acc.append(max_train_acc)
    fold_test_acc.append(max_test_acc)
    fold+=1

    for images, labels in test_dataset:
      logits = model(images, training=False)
      logits_max = tf.math.argmax(logits,1)
      labels_max = tf.math.argmax(labels,1)
      for i in range(len(logits)): conf_mat[labels_max[i]][logits_max[i]]+=1
  
  print()
  print('Learning Finished!')
  print(f'average train accuracy: {np.mean(fold_train_acc):.4f}')
  print(f'average test accuracy: {np.mean(fold_train_acc):.4f}')
  print(f'test std: {np.std(fold_train_acc):.4f}')
  print()

  conf_mat_normal = []
  for i in range(7):
    s = sum(conf_mat[i])
    if s==0: conf_mat_normal.append([0]*7)
    else: conf_mat_normal.append(list(map(lambda x:(x/s)*100, conf_mat[i])))
    conf_mat_normal[i].append(s)
  label = ['anger','boredom','disgust','fear','happy','sad','neutral']
  print('\t'+'\t'.join(label)+'\t#')
  for i in range(7):
    print(label[i], end='')
    for j in range(8): print('\t%2.0f'%conf_mat_normal[i][j], end=' ')
    print()